import { version } from '../../../package.json'
import { relative, dirname } from 'path'
import { PathToNameAndType, VisitState } from './inspector/visit.js'
import { mkdir, writeFile } from 'fs/promises'

export const getFileImportRelativePath = (
  from: string,
  to: string,
  packageMappings: Record<string, string>
): string => {
  let filePath = relative(dirname(from), to)
  if (!filePath.startsWith('.')) {
    filePath = `./${filePath}`
  }
  for (const [path, packageName] of Object.entries(packageMappings)) {
    if (to.includes(path)) {
      filePath = filePath.replace(new RegExp(`.*${path}`), packageName)
      break
    }
  }
  return filePath.replace('.ts', '')
}

interface Meta {
  file: string
  variable: string
  type: string
  typePath: string
}

export type FilesAndMethods = {
  vrameworkConfig: Meta
  userSessionType: Meta
  sessionServicesType: Meta
  singletonServicesFactory: Meta
  sessionServicesFactory: Meta
}

export interface VrameworkCLIOptions {
  config?: string
  configFileType?: string
  userSessionType?: string
  singletonServicesFactoryType?: string
  sessionServicesFactoryType?: string
}

const getMetaTypes = (type: string, errors: Map<string, PathToNameAndType>, map: PathToNameAndType, desiredType?: string) => {
  if (desiredType) {
    const entries = Object.entries(map)
    for (const [file, meta] of entries) {
      for (const { type, variable, typePath } of meta) {
        if (type === desiredType) {
          return { file, variable, type, typePath }
        }
      }
    }
    errors.set(`No ${desiredType} found that extends ${type}`, map)
    return undefined
  }

  const totalValues = Object.values(map).flat()
  if (totalValues.length === 0) {
    errors.set(`No ${type} found`, map)
  } else if (totalValues.length > 1) {
    errors.set(`More than one ${type} found`, map)
  } else {
    const [file, [{ type, variable, typePath }]] = Object.entries(map)[0]
    return { file, type, variable, typePath }
  }

  return undefined
}

export const getVrameworkFilesAndMethods = async (
  {
    vrameworkConfigs,
    sessionServicesTypeImportMap: httpSessionServicesTypeImportMap,
    userSessionTypeImportMap,
    sessionServicesFactories,
    singletonServicesFactories,
  }: VisitState,
  packageMappings: Record<string, string>,
  outputFile: string,
  { configFileType, singletonServicesFactoryType, sessionServicesFactoryType }: VrameworkCLIOptions
): Promise<FilesAndMethods> => {
  let errors = new Map<string, PathToNameAndType>()

  const result: Partial<FilesAndMethods> = {
    vrameworkConfig: getMetaTypes('CoreConfig', errors, vrameworkConfigs, configFileType),
    userSessionType: getMetaTypes('CoreUserSession', errors, userSessionTypeImportMap, configFileType),
    sessionServicesType: getMetaTypes('CoreServices', errors, httpSessionServicesTypeImportMap),
    singletonServicesFactory: getMetaTypes('CreateSingletonServices', errors, singletonServicesFactories, singletonServicesFactoryType),
    sessionServicesFactory: getMetaTypes('CreateSessionServices', errors, sessionServicesFactories, sessionServicesFactoryType),
  }

  if (errors.size > 0) {
    const result: string[] = ['Found errors:']
    errors.forEach((filesAndMethods, message) => {
      result.push(`- ${message}`)
      for (const [file, methods] of Object.entries(filesAndMethods)) {
        result.push(
          `\t* file: ${getFileImportRelativePath(outputFile, file, packageMappings)}`
        )
        result.push(`\t* methods: ${methods.map(({ variable, type }) => `${variable}: ${type}`).join(', ')}`)
      }
    })

    console.error(result.join('\n'))
    process.exit(1)
  }

  return result as FilesAndMethods
}

export const writeFileInDir = async (path: string, content: string, ignoreModifyComment: boolean = false) => {
  if (content.includes('server-only')) {
    content = content.replace('\'server-only\'', `'server-only'\n\n${ignoreModifyComment ? '' : DO_NOT_MODIFY_COMMENT}`)
  } else {
    content = `${ignoreModifyComment ? '' : DO_NOT_MODIFY_COMMENT}${content}`
  }

  await mkdir(dirname(path), { recursive: true })
  await writeFile(path, content, 'utf-8')
}

export const logCommandInfoAndTime = async <ReturnType = void>(commandStart: string, commandEnd: string, callback: (...args: any[]) => Promise<ReturnType>) => {
  const start = Date.now()
  console.log(`\x1b[34m• ${commandStart}...\x1b[0m`)
  const result = await callback()
  console.log(`\x1b[32m✓ ${commandEnd} in ${Date.now() - start}ms.\x1b[0m`)
  return result
}

export const logVrameworkLogo = () => {
  console.log(`\x1b[33m⚙️ VRAMEWORK CLI ⚙️\n-------------------\x1b[0m`)
}

export const DO_NOT_MODIFY_COMMENT = `/**
* This file is generated by @vramework/cli@${version}
*/\n\n`